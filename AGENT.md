# AGENT.md

This file provides context to the AI assistant to help it understand the project and provide better assistance.

## Project Overview

This project is a web application generator for creating dynamic feature pages using page templates and pre-created widget. Page will take a config json and render to html placeholder also each widget will take its config json to fetch data and ui rendering behavior. Ideally there will be one single route for application /pages/app-page with a id as parameter. 

AppGenerator is Application generator (Apache Superset like but liter version) like with Angular 20+ that’s:

- Widget-based. Widget will fetch the data from backend through specific API, and configuration option user configured
- Widgets are kind of Template, dynamic components instances will be rendered on the placeholder independent of other instances of the Widget
- Page assembled from widgets
- Page is Configurable via JSON (no complex size/pixel adjusting builder)
- Uses pre-built templates for both widgets and pages
- Fast to implement in Angular without endless UI complexity
- Manage Widget and Page template registry
- template-driven, JSON-configurable dashboard builder — basically a “dashboard as data”, “Widget as data” approach, where the UI layout and behavior are fully driven by configuration JSON rather than hardcoded Angular components
- create/ configure application menu on navigation panel (the dynamic menu would be generated by a JSON fetched after successful login from server)
- simple Widget templates will be available for Chart component, Table component, Search component, Graph Component etc. data and option data will be fetched for specific instance of the widget
- menu will point to an instance of dashboard template

this Angular 20+ project is developed with "resource API" instead of HttpClient , Signal, without Zone dependency and all new construct like @if @else etc and new component naming guidelines. No SSR, use signal-based change detection, Services to use mock data and avoid HttpClient and Observable. Verify the application by running the relevant tests, including the Playwright script if possible.

# High-Level Architecture
* Config-Driven: All UI (dashboards, widgets, menu) are composed from configuration JSON returned by backend APIs.
* Widget System: Widgets are Angular components, but their appearance, API endpoints, and options are determined at run-time via config.
* Pre-Built Templates: For widgets and dashboard layouts—selected via config, not hardcoded into routes/components.
* Dynamic Menu: Fetch post-login; renders dashboard/widget entries dynamically.
* No "Builder" UI: Editing occurs by manipulating JSON (e.g., admin JSON editor), not drag-n-drop.
* Simple, Re-Usable Angular Patterns: Uses *ngFor, *ngIf, structural directives, and host binding, but little to no complex Angular Forms or heavy state management.

## Core Services
### ConfigService
* Fetches all config from backend (menus, widget types/templates, dashboard layouts, etc.).

### Dynamic Page Rendering
PageGenerator Component
* Receives a page config object (JSON).
* Uses <app-widget-host> for each widget.
* Passes config to host; host creates correct widget component via

### Config Service
* Fetching JSON config from API/asset

### Widget Loader
WidgetHostComponent
* Takes a widget config JSON, looks up which Angular component to instantiate, supplies config as @Input.
* Use a registry map ({ type: AngularComponent }) for widget lookup.

### WidgetRegistry
* Central map of widget type → Angular component.
* Add new widget? Just add to this registry.

### Widget Implementation
Each widget:
* Accepts a config via @Inject config: any
* Fetches data from specified API endpoint (config.apiUrl) with parameter
* Renders data per template-style (can have variant templates in component, switched via config param)

### Dynamic Menu
* Menu config (JSON) is fetched post-login.
* menu.component uses *ngFor to create navigation items.
* Route params & links driven by JSON structure.

### Templates for Widgets/Pages
In code, widgets have several “template” variants; select variant via config.
* Pages can be single-column, two-column, grid—handled by config (“layout”: “two-column”, ...).
* Compose layout in <pages.html> accordingly, using container classes.

### Fast Implementation
* Keep the registry of widgets and dashboard layouts simple.
* Avoid state management libraries unless truly needed—RxJS observables and Angular services suffice.
* Make all config observable/async; refresh and update as soon as new config supplied.
* Testing and preview: allow JSON config to be pasted and previewed in a special route.

### Add New Widget
* Implement a new Angular component with the widget contract (@Inject('WIDGET_CONFIG') config).
* Add it to the WidgetRegistryService under a unique type string.
* Create a JSON example for it and add to dashboard config.

### Sample Flow
* User logs in → backend returns menu config JSON.
* Menu renders
* User selects pages url → app fetches pages config JSON.
* PageComponent dynamically renders layout and widgets, passing config
* WidgetHostComponent creates appropriate widget, passing its config
* WidgetComponent performs API fetch and renders data as defined by config/template.

### Design guide:
* Robust, scalable, and maintainable.
* Keeps Angular implementation minimal and focused.
* All UI behavior/layout is “data-driven” through JSON, as requested.

## Architecture

The application is built using Angular for the frontend and a java backend (spring boot / quarkus). It follows a component-based architecture.

-   `src/app/core`: Core modules, services, and models.

## Key Libraries and Frameworks

-   **Angular**: The primary framework for the frontend. version 20.1.4
-   **NgRx (optional)**: For state management if the application becomes complex.
-   **G6 or similar**: https://g6.antv.antgroup.com For data visualizations in the dashboards.
-   **Angular Material**: For UI components.

## Coding Conventions

-   Follow the official [Angular Style Guide](https://angular.dev/style-guide).
-   Use TypeScript strict mode.
-   Components should have `OnPush` change detection strategy where possible.
-   Services should be provided in `root` unless they are specific to a feature module.

## Rules
-   Use Angular 20 version features wherever possible.
-   Avoid Observables and RxJS as much as possible.
-   Use resources with signals (preview features are ok).
-   Avoid deprecated syntax and features.
-   Use generics and follow the DRY (Don't Repeat Yourself) principle.
-   Always include type annotations for function parameters.
-   Avoid using default exports; prefer named exports.

## Do's and Don'ts

**Do:**
-   Create a new feature module for each new major feature.
-   Use shared components for UI elements that are used in multiple places.
-   Write unit tests for components and services.

**Don't:**

-   Put business logic directly into components. Use services for that.
-   Modify files in the `core` module without careful consideration.

## Important Files

## Major Modules
