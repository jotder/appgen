AppGenerator is Application generator (Apache Superset like but liter version) like with Angular 20+ that’s:

- Widget-based. Widget will fetch the data from backend through specific API, and configuration option user configured
- Widgets are kind of Template/Class, specific/dynamic components instances will be rendered on the placeholder independent of other instances of the same Widget
- Page assembled from widgets
- Configurable via JSON (no complex drag-and-drop builder)
- Uses pre-built templates for both widgets and pages
- Fast to implement in Angular without endless UI complexity
- Manage Widget and Page template registry
- template-driven, JSON-configurable page builder — basically a “page as data”, “Widget as data” approach, where the UI layout and behavior are fully driven by configuration JSON rather than hardcoded Angular components
- create/ configure application menu on navigation panel (the dynamic menu would be generated by a JSON fetched after successful login from server)
- simple Widget templates will be available for Chart component, Table component, Search component, Graph Component etc. data and option data will be fetched for specific instance of the wizard  
- menu will point to an instance of page template

this Angular 20+ project is developed with "resource API" instead of HttpClient , Signal, without Zone dependency and all new construct like @if @else etc and new component naming guidelines. No SSR, use signal-based change detection, Services to use mock data and avoid HttpClient and Observable. Verify the application by running the relevant tests, including the Playwright script if possible.

# High-Level Architecture
* Config-Driven: All UI (pages, widgets, menu) are composed from configuration JSON returned by backend APIs.
* Widget System: Widgets are Angular components, but their appearance, API endpoints, and options are determined at run-time via config.
* Pre-Built Templates: For widgets and page layouts—selected via config, not hardcoded into routes/components.
* Dynamic Menu: Fetch post-login; renders page/widget entries dynamically.
* No "Builder" UI: Editing occurs by manipulating JSON (e.g., admin JSON editor), not drag-n-drop.
* Simple, Re-Usable Angular Patterns: Uses *ngFor, *ngIf, structural directives, and host binding, but little to no complex Angular Forms or heavy state management.

## Core Services
### ConfigService
* Fetches all config from backend (menus, widget types/templates, page layouts, etc.).

### Dynamic Page Rendering
PageGenerator Component
* Receives a page config object (JSON).
* Uses <app-widget-host> for each widget.
* Passes config to host; host creates correct widget component via

### Config Service 
* Fetching JSON config from API/asset

### Widget Loader
WidgetHostComponent
* Takes a widget config JSON, looks up which Angular component to instantiate, supplies config as @Input.
* Use a registry map ({ type: AngularComponent }) for widget lookup.

### WidgetRegistry
* Central map of widget type → Angular component.
* Add new widget? Just add to this registry.

### Widget Implementation
Each widget:
* Accepts a config via @Inject config: any
* Fetches data from specified API endpoint (config.apiUrl) with parameter
* Renders data per template-style (can have variant templates in component, switched via config param)

### Dynamic Menu
* Menu config (JSON) is fetched post-login.
* menu.component uses *ngFor to create navigation items.
* Route params & links driven by JSON structure.

### Page/Widget JSON Structure Example
Page JSON

    // page.config.json
    {
        "pages": [
            {
                "id": "main",
                "title": "Main Page",
                "layout": "two-column",
                "widgets": [
                    {
                        "instanceId": "w1",
                        "type": "counter",
                        "config": { "label": "Users", "apiUrl": "/api/users/count" }
                    },
                    {
                        "instanceId": "w2",
                        "type": "message",
                        "config": { "text": "Welcome to Superset-lite demo!" }
                    }
                ]
            },
            {
                "id": "simple",
                "title": "Simple Page",
                "layout": "single-column",
                "widgets": [
                    {
                        "instanceId": "w3",
                        "type": "message",
                        "config": { "text": "This is a single widget page." }
                    }
                ]
            }
        ]
    }

Menu JSON

    {
        "items": [
            { "label": "Sales", "route": "/pages/sales-page" },
            { "label": "Inventory", "route": "/pages/inventory-page" }
        ]
    }

### Templates for Widgets/Pages
In code, widgets have several “template” variants; select variant via config.
* Pages can be single-column, two-column, grid—handled by config (“layout”: “two-column”, ...).
* Compose layout in <pages.html> accordingly, using container classes.

### Fast Implementation
* Keep the registry of widgets and page layouts simple.
* Avoid state management libraries unless truly needed—RxJS observables and Angular services suffice.
* Make all config observable/async; refresh and update as soon as new config supplied.
* Testing and preview: allow JSON config to be pasted and previewed in a special route.

### Add New Widget
* Implement a new Angular component with the widget contract (@Inject('WIDGET_CONFIG') config).
* Add it to the WidgetRegistryService under a unique type string.
* Create a JSON example for it and add to page config.

### Sample Flow
* User logs in → backend returns menu config JSON.
* Menu renders
* User selects pages url → app fetches pages config JSON.
* PageComponent dynamically renders layout and widgets, passing config
* WidgetHostComponent creates appropriate widget, passing its config
* WidgetComponent performs API fetch and renders data as defined by config/template.

### Design guide:
* Robust, scalable, and maintainable.
* Keeps Angular implementation minimal and focused.
* All UI behavior/layout is “data-driven” through JSON, as requested.

### Sample Widget Models
    
    export interface WidgetPreference {
        widgetId: string;
        refreshIntervalMs: number;
        paused: boolean;
        customConfig?: any;
    }
    
    export interface PagePreference {
        id: string;                  // Preference record ID
        userId: string;               // Admin user ID
        pageTemplateId: string;  // Which page template it applies to
        widgets: WidgetPreference[];  // Per-widget settings
        lastUpdated: string;          // ISO timestamp
    }

    export interface PageState {
        pageId: string; // which page
        widgets: WidgetConfig[];
        filters: { [key: string]: any };
        layout: any; // could be a grid layout object
    }
    


    interface PageState {
        route: string;
        dashboardTemplateId: string;
        widgets: Record<string, WidgetState>;
        globalScrollY: number;
        lastUpdated: number;
    }
    
    interface WidgetState {
        filterValues: Record<string, any>;
        refreshInterval: number;
        collapsed: boolean;
        scrollY: number;
    }

    import { ID, Timestamp } from './common';
    
    export type WidgetTypeId =
    | 'JobSummaryChart'
    | 'AlertsList'
    | 'UserActivityLog'
    | 'CasesByStatusDonut'
    | 'JobsNextRunTable'
    | 'NotificationsStream';
    
    export interface WidgetSchema {
        /** Basic JSON Schema draft-lite we’ll support */
        $id?: string
        title?: string
        type: 'object'
        properties: Record<string, {
            type: 'string'|'number'|'boolean'|'array'|'object';
            title?: string;
            description?: string;
            enum?: any[];
            items?: { type: 'string'|'number'|'boolean'|'object' };
            default?: any;
        }
        required?: string[];
    }
    
    export interface WidgetTypeDef {
        id: WidgetTypeId;
        name: string;
        description?: string;        /** Where data comes from by default (can be overridden per config) */
        defaultApi?: string;        /** JSON schema to render dynamic form */
        schema: WidgetSchema;        /** Optional preview hint */
        previewExample?: Record<string, any>;
    }
    
    export interface WidgetConfig {
        id: ID;
        name: string;
        widgetType: WidgetTypeId;
        params: Record<string, any>;
        tags?: string[];
        createdBy?: string;
        createdAt?: Timestamp;
        updatedAt?: Timestamp;
        version?: number;
    }


    export interface Page {
        id: ID;
        name: string;
        layout: {
        columns: number;
        };
        // We store widget instances (pointing to a WidgetConfig)
        widgets: PageWidget[];
        createdBy?: string;
        createdAt?: Timestamp;
        updatedAt?: Timestamp;
    }
    
    export interface PageWidget {
        id: ID;
        widgetConfigId: ID;
        titleOverride?: string;
        position: { colStart: number; colSpan: number; row?: number }; // simple grid
    }


### Sample page-editor     


### Sample Widget Configuration Manager

















