AppGenerator is Application generator (Apache Superset like but liter version) like with Angular 20+ that’s:

- Widget-based. Widget will fetch the data from backend through specific API, and configuration option user configured
- Widgets are kind of Template/Class, specific/dynamic components instances will be rendered on the placeholder independent of other instances of the same Widget
- Page assembled from widgets
- Configurable via JSON (no complex drag-and-drop builder)
- Uses pre-built templates for both widgets and dashboards
- Fast to implement in Angular without endless UI complexity
- Manage Widget and Page template registry
- template-driven, JSON-configurable dashboard builder — basically a “dashboard as data”, “Widget as data” approach, where the UI layout and behavior are fully driven by configuration JSON rather than hardcoded Angular components
- create/ configure application menu on navigation panel (the dynamic menu would be generated by a JSON fetched after successful login from server)
- simple Widget templates will be available for Chart component, Table component, Search component, Graph Component etc. data and option data will be fetched for specific instance of the wizard  
- menu will point to an instance of dashboard template

this Angular 20+ project is developed with "resource API" instead of HttpClient , Signal, without Zone dependency and all new construct like @if @else etc and new component naming guidelines

# High-Level Architecture
* Config-Driven: All UI (dashboards, widgets, menu) are composed from configuration JSON returned by backend APIs.
* Widget System: Widgets are Angular components, but their appearance, API endpoints, and options are determined at run-time via config.
* Pre-Built Templates: For widgets and dashboard layouts—selected via config, not hardcoded into routes/components.
* Dynamic Menu: Fetch post-login; renders dashboard/widget entries dynamically.
* No "Builder" UI: Editing occurs by manipulating JSON (e.g., admin JSON editor), not drag-n-drop.
* Simple, Re-Usable Angular Patterns: Uses *ngFor, *ngIf, structural directives, and host binding, but little to no complex Angular Forms or heavy state management.

## Core Services
### ConfigService
* Fetches all config from backend (menus, widget types/templates, dashboard layouts, etc.).

### Dynamic Page Rendering
PageGenerator Component
* Receives a page config object (JSON).
* Uses <app-widget-host> for each widget.
* Passes config to host; host creates correct widget component via

### Config Service 
* Fetching JSON config from API/asset

### Widget Loader
WidgetHostComponent
* Takes a widget config JSON, looks up which Angular component to instantiate, supplies config as @Input.
* Use a registry map ({ type: AngularComponent }) for widget lookup.

### WidgetRegistry
* Central map of widget type → Angular component.
* Add new widget? Just add to this registry.

### Widget Implementation
Each widget:
* Accepts a config via @Inject config: any
* Fetches data from specified API endpoint (config.apiUrl) with parameter
* Renders data per template-style (can have variant templates in component, switched via config param)

### Dynamic Menu
* Menu config (JSON) is fetched post-login.
* menu.component uses *ngFor to create navigation items.
* Route params & links driven by JSON structure.

### Page/Widget JSON Structure Example
Page JSON

    // dashboard.config.json
    {
        "dashboards": [
            {
                "id": "main",
                "title": "Main Page",
                "layout": "two-column",
                "widgets": [
                    {
                        "instanceId": "w1",
                        "type": "counter",
                        "config": { "label": "Users", "apiUrl": "/api/users/count" }
                    },
                    {
                        "instanceId": "w2",
                        "type": "message",
                        "config": { "text": "Welcome to Superset-lite demo!" }
                    }
                ]
            },
            {
                "id": "simple",
                "title": "Simple Page",
                "layout": "single-column",
                "widgets": [
                    {
                        "instanceId": "w3",
                        "type": "message",
                        "config": { "text": "This is a single widget dashboard." }
                    }
                ]
            }
        ]
    }

Menu JSON

    {
        "items": [
            { "label": "Sales", "route": "/pages/sales-page" },
            { "label": "Inventory", "route": "/pages/inventory-page" }
        ]
    }

### Templates for Widgets/Pages
In code, widgets have several “template” variants; select variant via config.
* Pages can be single-column, two-column, grid—handled by config (“layout”: “two-column”, ...).
* Compose layout in <pages.html> accordingly, using container classes.

### Fast Implementation
* Keep the registry of widgets and dashboard layouts simple.
* Avoid state management libraries unless truly needed—RxJS observables and Angular services suffice.
* Make all config observable/async; refresh and update as soon as new config supplied.
* Testing and preview: allow JSON config to be pasted and previewed in a special route.

### Add New Widget
* Implement a new Angular component with the widget contract (@Inject('WIDGET_CONFIG') config).
* Add it to the WidgetRegistryService under a unique type string.
* Create a JSON example for it and add to dashboard config.

### Sample Flow
* User logs in → backend returns menu config JSON.
* Menu renders
* User selects pages url → app fetches pages config JSON.
* PageComponent dynamically renders layout and widgets, passing config
* WidgetHostComponent creates appropriate widget, passing its config
* WidgetComponent performs API fetch and renders data as defined by config/template.

### Design guide:
* Robust, scalable, and maintainable.
* Keeps Angular implementation minimal and focused.
* All UI behavior/layout is “data-driven” through JSON, as requested.


    src/
    ├─ app/
    │   ├─ core/            # Core services, guards, interceptors
    │   │    ├─ auth/                        
    │   │    │   ├─ auth.service.ts
    │   │    │   ├─ session-restore.service.ts
    │   │    │   ├─ toast.service.ts
    │   │    │   ├─ api-interceptor.ts
    │   │    │   ├─ auth.guard.ts
    │   │    ├─ generator/                        
    │   │        │─ page-generator.ts   # Generate Pages from page template which contains widgets                    
    │   │        │─ widget-generator.ts # Generate Widgets from widget template which contains API, config options
    │   │        ├─ widget-manager.ts
    │   │        ├─ page-editor.ts
    │   ├─ pages/
    │       ├─app-page.ts      # Route for the application page, render with generator engine and config json
    │   
    ├─ layouts/                     # Layout wrappers / Menu for app-page with id/name
    │   │   ├─ main.layout.ts
    │   │   ├─ admin.layout.ts      # Layout wrappers page design and create application
    │   │
    │   ├─ shared/                  # Shared UI elements
    │       ├─ table.ts
    │       ├─ form-field.ts
    │       ├─ confirm-dialog.ts
    ├─ settings/
    │   ├─ settings.page.ts
    │   ├─ profile.page.ts
    │   ├─ preferences.page.ts
    │
    ├─ control-panel/
    │       ├─ templates/
    │            ├─ widgets/          # All dashboard widgets
    │            │      ├─ tables/
    │            │      │       ├─ table-simple.ts
    │            │      │       ├─ table-seatch.ts
    │            │      │       ├─ table-crud.ts
    │            │      ├─ charts/
    │            │      │       ├─ line-chart.ts
    │            │      │       ├─ pi-chart.ts
    │            │      │       ├─ bubble-chart.ts
    │            │      │       ├─ area-chart.ts
    │            │      ├─ graphs/
    │            │      │       ├─ sortest-path.ts
    │            │      │       ├─ zoom-graph.ts
    │            │      ├─ components/
    │            │              ├─ dialog.ts
    │            │              ├─ detail.ts
    │            │              ├─ rule-edit.ts
    │            │              ├─ form-simple.ts
    │            │              ├─ form-lookup.ts
    |            ├─ pages/
    │                   ├─ rules/
    │                   │   ├─ rules.ts
    │                   │   ├─ rule-form.ts
    │                   │
    │                   ├─ jobs/
    │                   │   ├─ jobs.ts
    │                   │   ├─ job-instance.ts
    │                   │
    │                   ├─ notification/
    │                   │   ├─ notification.ts
    │                   │
    │                   ├─ cases/
    │                   │   ├─ cases.ts
    │                   │   ├─ case-states.ts
    │                   │
    │                   ├─ reports/
    │                   │   ├─ reports.ts
    │                   │
    │                   ├─ user-activity/
    │                   │   ├─ user-activity.ts
    │                   │
    │                   ├─ dashboards/                      # Page Layouts
    │                       ├─ executive-dashboard.ts
    │                       ├─ analytical-detail.ts
    │                       ├─ widget-config-manager.ts
    │                       ├─ widget-config.ts
    ├─ app.routes.ts
    ├─ app.config.ts
    ├─ main.ts
    │
    ├─ assets/
    ├─ environments/

### Sample Widget Models
    
    export interface WidgetPreference {
        widgetId: string;
        refreshIntervalMs: number;
        paused: boolean;
        customConfig?: any;
    }
    
    export interface PagePreference {
        id: string;                  // Preference record ID
        userId: string;               // Admin user ID
        pageTemplateId: string;  // Which page template it applies to
        widgets: WidgetPreference[];  // Per-widget settings
        lastUpdated: string;          // ISO timestamp
    }

    export interface PageState {
        pageId: string; // which page
        widgets: WidgetConfig[];
        filters: { [key: string]: any };
        layout: any; // could be a grid layout object
    }
    


    interface PageState {
        route: string;
        dashboardTemplateId: string;
        widgets: Record<string, WidgetState>;
        globalScrollY: number;
        lastUpdated: number;
    }
    
    interface WidgetState {
        filterValues: Record<string, any>;
        refreshInterval: number;
        collapsed: boolean;
        scrollY: number;
    }

    import { ID, Timestamp } from './common';
    
    export type WidgetTypeId =
    | 'JobSummaryChart'
    | 'AlertsList'
    | 'UserActivityLog'
    | 'CasesByStatusDonut'
    | 'JobsNextRunTable'
    | 'NotificationsStream';
    
    export interface WidgetSchema {
        /** Basic JSON Schema draft-lite we’ll support */
        $id?: string
        title?: string
        type: 'object'
        properties: Record<string, {
            type: 'string'|'number'|'boolean'|'array'|'object';
            title?: string;
            description?: string;
            enum?: any[];
            items?: { type: 'string'|'number'|'boolean'|'object' };
            default?: any;
        }
        required?: string[];
    }
    
    export interface WidgetTypeDef {
        id: WidgetTypeId;
        name: string;
        description?: string;        /** Where data comes from by default (can be overridden per config) */
        defaultApi?: string;        /** JSON schema to render dynamic form */
        schema: WidgetSchema;        /** Optional preview hint */
        previewExample?: Record<string, any>;
    }
    
    export interface WidgetConfig {
        id: ID;
        name: string;
        widgetType: WidgetTypeId;
        params: Record<string, any>;
        tags?: string[];
        createdBy?: string;
        createdAt?: Timestamp;
        updatedAt?: Timestamp;
        version?: number;
    }


    export interface Page {
        id: ID;
        name: string;
        layout: {
        columns: number;
        };
        // We store widget instances (pointing to a WidgetConfig)
        widgets: PageWidget[];
        createdBy?: string;
        createdAt?: Timestamp;
        updatedAt?: Timestamp;
    }
    
    export interface PageWidget {
        id: ID;
        widgetConfigId: ID;
        titleOverride?: string;
        position: { colStart: number; colSpan: number; row?: number }; // simple grid
    }


### Sample page-editor     
    @Component({
        selector: 'page-editor',
        standalone: true,
        imports: [CommonModule],
        templateUrl: './dashboard-editor.html'
    })
    export class PageEditorComponent implements OnInit {
        pages = signal<Page[]>([]);
        selected = signal<Page|null>(null);
        widgetConfigs = signal<WidgetConfig[]>([]);
        
        constructor(
            private api: PageComposerService,
            private cfgApi: WidgetConfigService
        ) {}
        
        ngOnInit() {
            this.reload();
        }
        
        reload() {
            this.api.list().subscribe(ds => this.dashboards.set(ds));
            this.cfgApi.list().subscribe(cfgs => this.widgetConfigs.set(cfgs));
        }
        
        selectPage(d: Page) { this.selected.set(d); }
        
        newPage() {
            const d: Partial<Page> = { name: 'New Page', layout: { columns: 3 }, widgets: [] as any };
            this.api.create(d).subscribe(res => {
            this.reload();
            this.selected.set(res);
            });
        }
        
        savePage() {
            const d = this.selected();
            if (!d) return;
            this.api.update(d.id, d).subscribe(res => this.selected.set(res));
        }
        
        addWidget(config: WidgetConfig) {
            const d = this.selected();
            if (!d) return;
            const w: PageWidget = {
                id: uuid(),
                widgetConfigId: config.id,
                position: { colStart: 1, colSpan: 1 }
            };
            d.widgets.push(w);
            this.savePage();
        }
        
        removeWidget(widgetId: string) {
            const d = this.selected();
            if (!d) return;
            d.widgets = d.widgets.filter(w => w.id !== widgetId);
            this.savePage();
        }
        
        moveLeft(w: PageWidget) {
            w.position.colStart = Math.max(1, w.position.colStart - 1);
            this.savePage();
        }

        moveRight(w: PageWidget, columns: number) {
            w.position.colStart = Math.min(columns, w.position.colStart + 1);
            this.savePage();
        }

        widen(w: PageWidget, columns: number) {
            w.position.colSpan = Math.min(columns - w.position.colStart + 1, w.position.colSpan + 1);
            this.savePage();
        }

        narrow(w: PageWidget) {
            w.position.colSpan = Math.max(1, w.position.colSpan - 1);
            this.savePage();
        }
    }


### Sample Widget Configuration Manager

    import { Component, OnInit, computed, signal } from '@angular/core';
    import { CommonModule } from '@angular/common';
    import { WidgetConfigService } from '../../../core/services/widget-config';
    import { WidgetTypesRegistry } from '../../../core/services/widget-types';
    import { WidgetConfig } from '../../../core/models/widget-config';
    import { JsonSchemaFormComponent } from '../../../shared/components/json-schema-form/json-schema-form';
    
    @Component({
        selector: 'app-widget-config-manager',
        standalone: true,
        imports: [CommonModule, JsonSchemaFormComponent],
        templateUrl: './widget-config-manager.component.html'
    })
    export class WidgetConfigManagerComponent implements OnInit {
    configs = signal<WidgetConfig[]>([]);
    loading = signal(true);
    selected = signal<WidgetConfig|null>(null);
    formParams = signal<Record<string, any>>({});
    creating = signal<boolean>(false);
    
    constructor(
        private api: WidgetConfigService,
        public types: WidgetTypesRegistry
    ) {}
    
    ngOnInit() {
        this.reload();
    }
    
    reload() {
        this.loading.set(true);
        this.api.list().subscribe(data => {
        this.configs.set(data);
        this.loading.set(false);
        });
    }
    
    select(c: WidgetConfig) {
        this.creating.set(false);
        this.selected.set(c);
        this.formParams.set({ ...c.params });
    }
    
    newConfig() {
        this.creating.set(true);
        this.selected.set({
            id: '',
            name: 'New Config',
            widgetType: this.types.list()[0].id,
            params: {}
        });
        this.formParams.set({});
    }
    
    save() {
        const current = this.selected();
        if (!current) return;
        const payload = {
            ...current,
            params: this.formParams()
        };
        if (!current.id) {
            this.api.create(payload).subscribe(res => {
                this.selected.set(res);
                this.reload();
            });
        } else {
            this.api.update(current.id, payload).subscribe(res => {
                this.selected.set(res);
                this.reload();
            });
        }
    }
    
    remove(c: WidgetConfig) {
        if (!c.id) return;
        if (!confirm('Delete this widget config? Pages using it will be affected.')) return;
        this.api.delete(c.id).subscribe(() => {
            this.selected.set(null);
            this.reload();
        });
    }
    
    usage(c: WidgetConfig) {
        if (!c.id) return;
        this.api.usage(c.id).subscribe(res => {
            alert(`Used in dashboards: ${res.dashboards.map(d => d.name).join(', ') || '(none)'}`);
        });
    }
    
    schemaOfSelected() {
        const c = this.selected();
        if (!c) return null;
        return this.types.get(c.widgetType)?.schema ?? null;
        }
    }





















